We now present the results related to the coverability problem on the plain \acp{PN} which seem to us the most interesting.

To introduce these results, we need some additional definitions.
They will be given for plain \acp{PN}, but most of them are naturally extended to \acp{PPN}.

A \emph{coverability set} of an initialized \ac{PN} is an over-approximation of the reachability set that is precise enough to solve the coverability problem, and is, therefore, interesting for our study.
In order to define it formally, we need to know about the upward and downward closure of a (set of) marking(s).

\begin{defi}[Upward- and downward-closure on markings]
  Let $S \subseteq \mathbb{N}^{|P|}$ be a set of markings on the places $P$:
  \begin{itemize}
    \item The \emph{upward-closure} of $S$, noted $\upc(S)$, is the set
      $\{\marq \in \mathbb{N}^{|P|} \mid \exists \marqp \in S : \marqp \pleq \marq\}$,
    \item The \emph{downward-closure} of $S$, noted $\downc(S)$, is the set
      $\{\marq \in \mathbb{N}^{|P|} \mid \exists \marqp \in S : \marq \pleq \marqp\}$.
  \end{itemize}
  The closure of a marking \marq is the closure of the singleton $\{\marq\}$.
\end{defi}

For instance, with $\marq = (1, 2, 3)$, we have that its upward-closure is $\upc(\marq) = \{(i, j, k) \mid i \geq 1, j \geq 2, k \geq 3\}$.

\begin{defi}[Upward- and downward-closed set of markings]
  A set $S$ of markings is said \emph{upward-closed} if $S = \upc(S)$.
  It is said \emph{downward-closed} if $S = \downc(S)$.
\end{defi}

\begin{defi}[Coverability set \citep{Finkel87,Finkel90}]
  Given an initialized \ac{PN} $\tupleN = \PTm$, a \emph{coverability set} $S$ of \tupleN is a set of markings such that $\downc(S) = \downc(\Post^*(\marqi))$.
\end{defi}

Obviously, the minimal coverability set is $\downc(\Post^*(\marqi))$.
It is called the \emph{covering set} of \tupleN and is noted $\Cover(\tupleN)$.

\begin{defi}[Covering set]
  Let $\tupleN = \PTm$ be an initialized \ac{PN}. The \emph{covering set} $S$ of \tupleN, noted $\Cover(\tupleN)$, is the set $\{c \mid \exists c' \in \Post^*(\tupleN) : c \leq c' \}$.
\end{defi}

\begin{figure}[htbp]
  \label{fig:reach-and-cover-example}
  \centering
  \subfloat[A \ac{PN} ($|P| = 2$)]{
    \label{fig:two-net}
    \input{res/two-net}

  }

  \subfloat[The reachable markings]{
    \label{fig:two-reach}
    \input{res/two-reach}

  }\qquad
  \subfloat[The cover set]{
    \label{fig:two-cover}
    \input{res/two-cover}

  }
  \caption{Reachability and minimal coverability sets}
\end{figure}

The figure~\ref{fig:two-net} shows a marked \ac{PN} with two places.
One can therefore represents the markings as points on a plane.
The figure~\ref{fig:two-reach} shows the reachable markings in the form of an accessibility graph.
In~\ref{fig:two-cover} we see the minimal coverability set.

It worth notice that, in the context of \acp{PN}, the coverability problem for a set of markings $S$ may be defined as follows:
\begin{defi}[Coverability problem]
  \label{defi:upclocovprblm}
  Given a \ac{PN} \tupleN and an upward-closed set $U = \upc(S)$ of markings of \tupleN, detemine whether $\Post^*(\marqi) \cap U = \emptyset$.
\end{defi}

Sometimes the number of token in a place is unbounded (\lang{c.f.} the place boundedness problem).
Therefore, the reachability and coverability sets are infinite.
In a plain \ac{PN}, this is due to the existence of an increasing self-covering sequence.
\begin{defi}[Self-covering sequence]
  Given an initialized \ac{PN} $\tupleN = \PTm$,
  a self-covering sequence is a sequence of the form:
  \[
    \marqi \fire{\rho} \marq_i \fire{\sigma} \marq_j
  \]
  with $\rho$ and $\sigma$ two sequences of transitions of $T$
  and with $\marq_i \pleq \marq_j$.
\end{defi}

Note that, since $\marq_i \pleq \marq_j$, $\sigma$ is firable from $\marq_j$.
In addition, the monotonicity of \acp{PN} ensures that, with $\marqp_j$ given by $\marq_j \fire{\sigma} \marqp_j$, we have $\marq_j \pleq \marqp_j$.
Thus, we see that it is a sufficient condition for the \emph{non-termination} of the system (the system may be able to fire transitions infinitely often).
In fact, because $\pleq$ is a well quasi-order (Lemma~\ref{lemm:wqo}), one can find in any infinite sequence $\marqi \fire{} \marq_1 \fire{} \dots$ two markings $\marq_i$ and $\marq_j$ such that $\marq_i \pleq \marq_j$.
Therefore, any infinite sequence is self-covering, and the existence of such a sequence is also necessary for the non-termination of the system.

\begin{defi}[Increasing self-covering sequence]
  Given an initialized \ac{PN} $\tupleN = \PTm$,
  an increasing self-covering sequence is a sequence of the form:
  \[
    \marqi \fire{\rho} \marq_i \fire{\sigma} \marq_j
  \]
  with $\rho$ and $\sigma$ two sequences of transitions of $T$
  and with $\marq_i \prec \marq_j$.
\end{defi}

Let $Q \subseteq P$ be the set of places $Q = \{q \in P \mid \marq_i(q) < \marq_j(q)\}$.
$Q \neq \emptyset$ since $\marq_i \prec \marq_j$.

With a reasoning similar to the one above, we see that having such a sequence ensures that one can reach a marking $\marqp_j$ given by $\marq_j \fire{\sigma} \marqp_j$ such that $\marq_j \prec \marqp_j$.
Because of the constant effect of transitions, we know that $\forall q \in Q : \marq_j(q) < \marqp_j(q)$.
The unboundedness of the places in $Q$ follows.
\todo{A more formal proof that the existence of an increasing self-covering sequence is a necessary and sufficient condition for unboundedness on places is either to be done here or to be referenced.}

An \omark is a way to represent a set of markings which have the same number of tokens in some places, and may have any number of tokens, potentially an infinity, in the other places.
They are useful to effectively represent potentially infinite downward-closed set, like a coverability set or the sets of markings of an increasing self-covering sequence.

\begin{defi}[\omark]
  We define $\omega$ to be such that:
  $\omega \notin \mathbb{N}$
  and for all constant $c \in \mathbb{N}$:
  \begin{itemize}
    \item $c \leq \omega$
    \item $\omega + c = \omega$
    \item $\omega - c = \omega$
  \end{itemize}

  \emph{An \omark} \marq over a set of places $P$ is a function $\marq : P \mapsto \mathbb{N} \cup \{\omega\}$ that associates $\marq(p)$ tokens to each place $p \in P$.

  With $\mathbb{P}$ a set of parameters, $\omega \notin \mathbb{P}$,
  \emph{a parametric \omark} \marq over a set of places $P$ is a function $\marq : P \mapsto \mathbb{N} \cup \mathbb{P} \cup \{\omega\}$ that associates $\marq(p)$ tokens to each place $p \in P$.
\end{defi}

Note that an \omark \marq is a parametric \omark where $\marq(p) \in \mathbb{N} \cup \{\omega\}$ for all places $p \in P$.
Similarly, a parametric marking \marq is a parametric \omark where $\marq(p) \neq \omega$ for all places $p \in P$.
As for parametric markings, we often refer to a parametric \omark simply as \omark.

Having an \omark $\marq \in \Cover(\tupleN)$ denotes that for all marking $\marq_1$ such that $\marq_1(p) = \marq(p) \forall p \in \{p \mid \marq(p) \neq \omega\}$, there exists a marking $\marq_2$ in the reachability set of \tupleN such that $\marq_1 \prec \marq_2$.
Notice also that an \omark always stands for one and only one downward closed set.
Symmetrically, any downward closed set may be represented by a finite set of \omarks. \todo{Indeed...} \todo{See ... for a complete proof}

This allow to represent any infinite downward closed set of markings by a unique finite set of \omarks.

An upward closed set is always infinite.
It can be effectively represented through its unique set of minimal elements whose it is the upward closure \todo{citep\{someone\}}.
This is a direct consequence of the \todo{someone} lemma:
\todo{Someone's lemma: every set of tuple has finitely many minimal elements.}
Moreover this reprenstation is effective in the sense that the set may be manipulated through it.
\todo{cite\{someone\}} give the way to perform the operations on upward closed sets through their minimal elements.

\subsection{A general backward algorithm}

There exists a simple way to solve the coverability problem for all the examples of \acp{WSTS} above mentioned.
This algorithm was introduced by Abdulla \lang{et al.} \citep{Abdulla96}.
It is close of the one introduced earlier in \cite{Finkel90}.
Even if we do not see how to use it in the context of \ac{PPN}, we mention it here because it helps to grasp, by comparison with the Karp and Miller algorithm presented in the following section, where does lie the difficulties of the coverability problem.

Relying on the definition~\ref{defi:upclocovprblm} of the coverability problem, given an upward-closed set of markings $U$, the algorithm computes $\Pre^*(U)$ by iterating the $\Pre$ operator.
The termination and correction of the algorithm were proven in \todo{cite\{someone\}}.
The termination is ensured by the existence of a fixed point in the sequence of upward closed set of markings $(R_i)_{i \geq 0}$:
\begin{gather*}
  R_0 = U \\
  \forall i > 0 : R_i = R_{i-1} \cup \Pre(R_{i-1})
\end{gather*}
When this fixed point is reached, we have $\Pre^*(U)$.
If $\marqi \in \Pre^*(U)$, one can conclude positively.
The result is negative otherwise.

This approach is elegant and general, but often inefficient in practice.
It is well known that a forward exploration of the state of space (\lang{i.e.}, in this context, using $\Post$ instead of $\Pre$) is usually more efficient \todo{citep\{someone\}}.
We now present a forward algorithm, but whose the application is restricted to \ac{PN}.

\subsection{The Karp and Miller algorithm}

Although it was not originally designed for this purpose, the Karp and Miller algorithm \cite{Karp69} is a classical algorithm to compute a coverability set of an initialized \ac{PN}.
More precisely, it constructs a coverability tree and uses an acceleration function to systematically detect self-covering sequences, and thus ensures the termination.

\begin{defi}[Coverability tree]
  Given a \ac{PN} $\tupleN = \PTm$, a coverability tree $\mathcal{T}$ of \tupleN is a labelled tree $\mathcal{T} = \langle N, B, n_0, \Lambda\rangle$ where:
  \begin{itemize}
    \item $N$ is the set of nodes of the tree.%, is a set of \omark of \tupleN such that $\downc(N) = \Cover(\tupleN)$.
    \item $n_0 \in N$ is the root of the tree, \lang{i.e.} $\nexists n \in N$ such that $(n, n_0) \in B$.
    \item $\Lambda : N \mapsto (\mathbb{N} \cup \{\omega\})^{|P|}$ is a labelling function that associate to each node a \textomega-marking of \tupleN.
    \item $B \subseteq N \times N$, the set of edges, is such that:
      \begin{itemize}
        \item with $(n_1, n_2) \in N^2$, if there exists an edge $(n_1, n_2) \in B$ then there exists a sequence $\sigma$ of transitions of $T$ such that $\Lambda(n_1) \fire{\sigma} \Lambda(n_2)$,
        \item for all node $n \in N \setminus \{n_0\}$, there exists a path from the root to $n$, that is, there exists a sequence of edges of $B$ of the form $((n_0, n_1), (n_1, n_2), \dots, (n_{i}, n))$, $i \geq 1$, and
        \item there is no cycles, that is, there is no sequences of edges of $B$ of the form $((n_1, n_2), (n_2, n_3), \dots, (n_i, n_1))$.
      \end{itemize}
  \end{itemize}
  and such that $\downc(\{\Lambda(n) \mid n \in N\}) = \Cover(\tupleN)$.
\end{defi}

To keep $N$ finite, the Karp and Miller algorithm exploits the strong monotonicity of \acp{PN} to introduce \omark{}s through an \emph{acceleration function} $\KMAcc$.
This function takes a marking \marq to accelerate and a set of markings $S$ as a base \todo{?} for the acceleration and returns a marking $\marq_\omega$ such that:
\[
  \marq_\omega(p) =
  \begin{cases}
    \omega    &\text{if } \exists \marqp \in S : \marqp \prec \marq \text{ and } \marqp(p) < \marq(p) \\
    \marq(p)  &\text{otherwise}
  \end{cases}
\]

We denote by $\mathscr{T}_n$ the path in the tree from the root to $n$.

The algorithm constructs the tree $\mathcal{T}$ as follows:
The root $n_0$ of the tree is labelled with \marqi.
A frontier $F$ is defined to be the set of unprocessed nodes of the tree and is initialised to $\{n_0\}$.
Then, while $F$ is non empty, a node $n$ is chosen from $F$ to be processed:
it is removed from $F$ and, if there is no node $n'$ in $\mathscr{T}_n$ such that $\Lambda(n) = \Lambda(n')$, for all \omark in $\{\KMAcc(\marq, \mathscr{T}_n) \mid \marq \in \Post(\Lambda(n))\}$, a node labelled with $\KMAcc(\marq, \mathscr{T}_n)$ is added to the frontier and to the tree as a child of $n$.

The correctness and the termination of the algorithm lies on the strong monotonicity of \acp{PN}, and was proved by Karp and Miller in their work \cite{Karp69}.

The Karp and Miller tree has a lot of convenient properties, and allows to answer coverability problem. \todo{as well as ...}
Furthermore, the Karp and Miller algorithm can easily be adapted to some parametric problems \cite{David17}, as we will show in \todo{section~?}.

However, this tree, although finite, is often much larger than the minimal coverability set, and cannot be constructed in reasonable time.
As a consequence, many improvement were proposed, as well as other algorithms with different approaches.

\subsection{An efficient computation method of the coverability set of Petri nets}
\label{sec:eff}

In \cite{Geeraerts07thesis, Geeraerts07}, Geeraerts proposes another approach to the computation of the coverability set.
It is not based on the Karp and Miller algorithm and is not an alternative to it in the sense that it does not allow to answer the same set of questions than the Karp and Miller tree answers.
However, this technique solve the coverability problem more efficiently in practice.

As in the Karp and Miller algorithm, an acceleration function exploits the strong monotonicity of \acp{PN} to allow termination.
But here, the acceleration of a marking is performed with only one marking as the base (instead of a set of marking).

To choose the base to use, the algorithm works on pair of \omarks.
These pairs allow to record a relationship between the markings.
More precisely, the algorithm constructs a pair of \omarks $(\marq_1, \marq_2)$ only if $\downc(\marq_2) \subseteq \downc(\Post^*(\marq_1))$.
This relationship is of interest because it ensures that there exists a sequence $\sigma$ of transitions such that $\marq_1 \fire\sigma \marq_2$.
If, in addition, $\marq_1 \prec \marq_2$, we know than an acceleration may occur.

To reduce the size of the set of pairs of \omarks, only the pairs where the difference (as defined below) between $\marq_1$ and $\marq_2$ is maximal are kept.
This will be the purpose of the order $\sqsubseteq$ we will define and it is justified by the intuitive idea that two more distant markings produce larger accelerations.
Therefore, if the algorithm builds a pair $(\marq_1, \marq_2)$, it can forget about any other ($\sqsubseteq$-comparable) pair whose the elements are closer because
\begin{itemize}
  \item by monotonicity, all potential successor of the elements of this pair will be covered by successor of $\marq_1$ or $\marq_2$, and
  \item any acceleration that can be created from this pair is covered by an acceleration one can build from $(\marq_1, \marq_2)$.
\end{itemize}

To describe the algorithm more formally, we will need the following definitions:

Given a pair of \omarks $(\marq_1, \marq_2)$, we define:
\begin{itemize}
  \item $\Postb((\marq_1, \marq_2)) = \{(\marq_1, \marqp), (\marq_2, \marqp) \mid \marqp \in \Post(\marq_2)\}$,
  \item with $\marq_1 \prec \marq_2$, $\Accelb(\marq_1, \marq_2) = \{(\marq_2, \KMAcc(\{\marq_1\}, \marq_2))\}$.
    $\Accelb(\marq_1, \marq_2)$ is not defined whenever $\marq_1 \nprec \marq_2$,
\end{itemize}

With $R$ a set of pair of markings, we define:
\begin{itemize}
  \item $\Postb(R) = \bigcup_{(\marq_1, \marq_2) \in R} \Postb((\marq_1, \marq_2))$
  \item $\Accelb(R) = \bigcup_{(\marq_1, \marq_2) \in R}^{\marq_1 \prec \marq_2} \Accelb((\marq_1, \marq_2))$
  \item $\Flatten(R) = \{\marq \mid \exists \marqp : (\marqp, \marq) \in R\}$
\end{itemize}

The efficient computation of the coverability set of the marked \ac{PN} $\NPTm$ lies on the sequence $\CovSeq(\tupleN) = (V_i)_{i \geq 0}$ of pair of \omarks, where, for all marked \ac{PN} $\tupleN$ we have:
\begin{gather*}
  V_0 = \{(\marqi, \marqi)\} \text{ and } \\
  \forall i \geq 1 : V_i = V_{i-1} \cup \Postb(V_{i-1}) \cup \Accelb(V_{i-1})
\end{gather*}

One can shows that,
first, for all node $n$ of the Karp and Miller tree, there exists a value $k \geq 0$ of $i$ such that $\Lambda(n) \in \Flatten(V_k)$,
second, all the markings produced by $\Postb$ and $\Accelb$ are in the coverability set of \tupleN.
\todo{Indeed...}

These two results lead us to the following lemma:
\begin{lemm}[\cite{Geeraerts07}]
  Given a marked \ac{PN} \tupleN such that $\CovSeq(\tupleN) = (V_i)_{i \geq 0}$,
  there exists $k \geq 0$ such that for all $l \in \{0, ..., k-1\}$ we have that $\downc(\Flatten(V_l)) \subset \downc(\Flatten(V_{l+1}))$
  and for all $l \geq k : \downc(\Flatten(V_l)) = \Cover(\tupleN)$.
\end{lemm}

Thus, the algorithm idea is to compute $\CovSeq$ until it stabilizes, \lang{i.e.} to the lowest $l$ such that $\downc(\Flatten(V_l)) = \downc(\Flatten(V_{l-1}))$ and to return $\downc(\Flatten(V_l))$.

To perform it efficiently, one can use a well-chosen order $\sqsubseteq$ on the pair of markings to keep only the highest pairs with respect to this order.
Intuitively, they are the pair with the more distant elements.
Let us denote by $\ominus$ the componentwise difference between two markings and to extend it to \omarks.
Formally, given two \omarks $\marq_1$ and $\marq_2$ on a set of places $P$, $(\marq_1 \ominus \marq_2)(p)$ is defined for all $p \in P$ as:
\[
  \begin{cases}
    \omega & \text{ whenever } \marq_1(p) = \omega \\
    -\omega & \text{ whenever } \marq_2(p) = \omega \text{ and } \marq_1(p) \neq \omega \\
    \marq_1(p) - \marq_2(p) & \text{ otherwise}
  \end{cases}
\]

Now we can define $\sqsubseteq$.
Given two pairs $(\marq_1, \marq_2)$ and $(\marqp_1, \marqp_2)$ of \omarks over a set of places $P$:
\[
  (\marq_1, \marq_2) \sqsubseteq (\marqp_1, \marqp_2) \Leftrightarrow
  \begin{cases}
    & \marq_1 \pleq \marqp_1 \\
    \wedge & \marq_2 \pleq \marqp_2 \\
    \wedge & \forall p \in P : (\marq_2 \ominus \marq_1)(p) \leq (\marqp_2 \ominus \marqp_1)(p)
  \end{cases}
\]

For a set of pair of \omarks $R$, $\maxs(R) = \{ r \in R \mid \nexists r' \in R, r \sqsubseteq r'\}$ is the set of highest \omark of $R$ with respect to $\sqsubseteq$.

This order has properties \citep{Geeraerts07} that allows to keep the sets of markings of $\CovSeq$ small.
Thus, one can compute $\Cover(\tupleN)$ of a \ac{PN} \NPTm by computing the sequence $(V_i)_{i \geq 0}$ defined below until $\downc(\Flatten(V_i)) = \downc(\Flatten(V_{i-1}))$.
\begin{gather*}
  V_0 = \{(\marqi, \marqi)\} \text{ and } \\
  \forall i \geq 1 : V_i = \maxs(V_{i-1} \cup \Postb(V_{i-1}) \cup \Accelb(V_{i-1}))
\end{gather*}

At the end, we have that $\downc(\Flatten(V_i)) = \Cover(\tupleN)$.

The correction and termination of the algorithm as well as useful properties of $\sqsubseteq$ are presented in \cite{Geeraerts07, Ganty09}.

\subsection{The \ac{EEC} algorithm}
\label{sec:eec}

\ac{EEC}, introduced in \cite{Geeraerts07thesis, Geeraerts06}, is an iterative algorithm that allows, among other, to solve the coverability problem for \ac{PN}.
We present it restricted to this context, but it may be used for a wide range of well structured transitions systems, which \acp{PN} is part of, because it relies only on the monotonicity, and not on the strong monotonicity, of these models.

The idea is to compute and refine simultaneously an over- and an under-approximation of the covering set of the \ac{PN} until one or the other allows to conclude.

The under-approximation is computed as follows:
We define $(C_i)_{i \geq 0}$ to be the sequence of finite set of markings holding no more than $i$ tokens in each places (plus \marqi):
\[
  \forall i \in \mathbb{N} : C_i = \{0, ..., i\}^{|P|} \cup \{\marqi\}
\]
At step $i$, the algorithm computes $\Sous(\tupleN, C_i)$ defined as the graph $\langle C_i, \marqi, \sousrel \rangle$ which is the transition system induced by the \ac{PN} \tupleN restricted to the markings of $C_i$, \lang{i.e.} $(\marq_1, \marq_2) \in \sousrel$ if, and only if, $\marq_1 \rightarrow \marq_2$.
The under-approximation sought is the set of markings reachable through $\sousrel$ from \marqi and is denoted $\R(\Sous(\tupleN, C_i))$.

At step $i$, the algorithm also uses $L_i$ from the sequence $(L_i)_{i \geq 0}$ of finite set of \omarks such that $L_i = \{0, ..., i, \omega \}^{|P|} \cup \{\marqi\}$.
That is, $L_i$ contains all the markings with at most $i$ tokens in any place, or $\omega$ (plus \marqi).
This set is used to constructs the graph $\Sur(\tupleN, C_i)$ defined as the graph $\langle L_i, \marqi, \surrel \rangle$ where $(\marq_1, \marq_2) \in \surrel$ if, and only if:
\begin{itemize}
  \item either $\marq_1 \rightarrow \marq_2$,
  \item either $\marq_1 \rightarrow \marqp_2, \marqp_2 \notin L_i, \marqp_2 \pleq \marq_2, \text{ and } \nexists \marqpp_2 \in L_i \text{ such that } \marqp_2 \prec \marqpp_2 \prec \marq_2$.
\end{itemize}
In other words: if $\marq_2 \notin L_i$, it is replaced by the lowest marking of $L_i$ which over-approximate it.
Note that this is an \omark which exists and is unique. \todo{Indeed...}
The over-approximation, then, is the set of markings of $L_i$ reachable through $\surrel$ from \marqi. It is denoted $\R(\Sur(\tupleN, L_i))$.

We can say that they are under- and over-approximations thanks to the following lemmata:
\begin{lemm}[Under-approximation \cite{Ganty09}]
  For all \ac{PN} \NPTm, for all upward-closed set $U \subseteq \mathbb{N}^{|P|}$, and for all $i \geq 0: \R(\Sous(\tupleN,C_i)) \cap U \neq \emptyset \Rightarrow \Post^*(\marqi) \cap U \neq \emptyset$.
\end{lemm}
\begin{lemm}[Over-approximation \cite{Ganty09}]
  For all \ac{PN} \NPTm, for all upward-closed set $U \subseteq \mathbb{N}^{|P|}$, and for all $i \geq 0: \downc(\R(\Sur(\tupleN,L_i))) \cap U = \emptyset \Rightarrow \Post^*(\marqi) \cap U = \emptyset$.
\end{lemm}

One can prove that one of the conditions mentioned in the lemmata will eventually happen.
This ensures the termination of the algorithm.

Indeed, let $S$ be the set of markings we wants to cover and let $U$ be $\upc(S)$.
If $U$ is reachable, we will eventually get a $C_i$ that contains all the markings of a path from $\marqi$ to $U$.
As this path will be present in $\Sous(\tupleN, C_i)$, we will have that $\R(\Sous(\tupleN,C_i)) \cap U \neq \emptyset$.\\
Symmetrically, let $j$ be such that $L_j$ contains the maximal elements of the cover set of \tupleN.
Such a $j$ exists and we have that $\downc(\R(\Sur(\tupleN,L_j))) = \Cover(\tupleN)$.
Thus we know that $\downc(\R(\Sur(\tupleN,L_i))) \cap U = \emptyset$ will eventually happen for a $i \leq j$.


\removed{A backward algorithm \citep{Finkel90, Abdulla96}}
%\subsection{A backward algorithm \citep{Finkel90, Abdulla96}}
%
%We will now present an algorithm to solve the coverability problem for a marking \marq of a \ac{PN} $\tupleN = \PTm$.
%
%This algorithm was introduced by Abdulla \lang{et al.} \cite{Abdulla96} for well structured transition systems, a more general class of models which includes \acp{PN}.
%It is close of the one introduced earlier in \cite{Finkel90}.
%
%Recall the definition for a marking of being coverable.
%\coverability*
%
%For convenience, we will use an other equivalent definition.
%
%\begin{defi}[Coverability]
%  Given an initialized \ac{PN} \NPTm and an upward-closed set $U$, $U$ is said coverable if there exists a marking \marqp such that $\marqp \in U$ and $\marqi \fire{*} \marqp$.
%\end{defi}
%
%By choosing $\upc(\marq)$ as $U$, these two definitions set out the same instance of the coverability problem.
%With a set of markings considered in the first definition, $U$ may be the union of their upward-closure in the second.
%
%We say it is a backward algorithm in the sense that it is based on the computation of the set $\Pre^*(\marq)$ and answer by checking whether $\marqi \in \Pre^*(\marq)$; unlike a forward approach which would have calculated the reachability set and conclude by checking whether \marq was in it. In other words, it compute all the configurations that can reach $U$ in any number of steps.
%
%The calculation is a fixed point algorithm that compute the increasing sequence, for the inclusion relation, of sets of markings: $(R_n)_{n \in \mathbb{N}}$, with $R_0 = U$ and $R_{n+1} = \Pre(R_n) \cup R_n$.
%Thus, $R_n$ is the set of markings from which there exists a sequence of at most $n$ transitions which may be fired and that cover $U$.
%Because, with $U$ an upward-closed set of markings, $\Pre(U)$ is upward-closed too%
%\footnote{This is due to the monotonicity of \acp{PN}, \todo{see for example cite\{someone\}}},
%and because the union of two upward-closed sets is an upward-closed set,
%$R_n$ is upward-closed for all $n$.
%
%\todo{summarize correctness and termination from \cite{Abdulla96}}

% vim: set spell spelllang=en :
