We now present the results related to the coverability problem on the plain \acp{PN} which seem to us the most interesting.

To introduce these results, we need some additional definitions.
They will be given for plain \acp{PN}, but most of them are naturally extended to \acp{PPN}.

The \emph{coverability set} of an initialized \ac{PN} is an over-approximation of the reachability set that is precise enough to solve the coverability problem, and is, therefore, interesting for our study.
In order to define it formally, we need to know about the upward and downward closure of a (set of) marking(s).

\begin{defi}[Upward- and downward-closure on markings]
  Let $S \subseteq \mathbb{N}^{|P|}$ be a set of markings on the places $P$:
  \begin{itemize}
    \item The \emph{upward-closure} of $S$, noted $\upc(S)$, is the set
      $\{\marq \in \mathbb{N}^{|P|} \mid \exists \marqp \in S : \marqp \pleq \marq\}$,
    \item The \emph{downward-closure} of $S$, noted $\downc(S)$, is the set
      $\{\marq \in \mathbb{N}^{|P|} \mid \exists \marqp \in S : \marq \pleq \marqp\}$.
  \end{itemize}
  The closure of a marking \marq is the closure of the singleton $\{\marq\}$.
\end{defi}

For instance, with $\marq = (1, 2, 3)$, we have that its upward-closure is $\upc(\marq) = \{(i, j, k) \mid i \geq 1, j \geq 2, k \geq 3\}$.

\begin{defi}[Upward- and downward-closed set of markings]
  A set $S$ of markings is said \emph{upward-closed} if $S = \upc(S)$.
  It is said \emph{downward-closed} if $S = \downc(S)$.
\end{defi}

\begin{defi}[Coverability set \citep{Finkel87,Finkel90}]
  Given an initialized \ac{PN} $\tupleN = \PTm$, a \emph{coverability set} $S$ of \tupleN is a set of markings such that $\downc(S) = \downc(\Post^*(\marqi))$.
  
  Obviously, the minimal coverability set is thus $\downc(\Post^*(\marqi))$ and is noted $\Cover(\tupleN)$.
\end{defi}

\begin{figure}[htbp]
  \label{fig:reach-and-cover-example}
  \centering
  \subfloat[A \ac{PN} ($|P| = 2$)]{
    \label{fig:two-net}
    \input{res/two-net}

  }

  \subfloat[The reachable markings]{
    \label{fig:two-reach}
    \input{res/two-reach}

  }\qquad
  \subfloat[The minimal coverability set]{
    \label{fig:two-cover}
    \input{res/two-cover}

  }
  \caption{Reachability and minimal coverability sets}
\end{figure}

The figure~\ref{fig:two-net} shows a marked \ac{PN} with two places.
One can therefore represents the markings as points on a plane.
The figure~\ref{fig:two-reach} shows the reachable markings in the form of an accessibility graph.
In~\ref{fig:two-cover} we see the minimal coverability set.

Sometimes the number of token in a place is unbounded (\lang{c.f.} the place boundedness problem).
Therefore, the reachability and coverability sets are infinite.
In a plain \ac{PN}, this is due to the existence of an increasing self-covering sequence.
\begin{defi}[Self-covering sequence]
  Given an initialized \ac{PN} $\tupleN = \PTm$,
  a self-covering sequence is a sequence of the form:
  \[
    \marqi \fire{\rho} \marq_i \fire{\sigma} \marq_j
  \]
  with $\rho$ and $\sigma$ two sequences of transitions of $T$
  and with $\marq_i \pleq \marq_j$.
\end{defi}

Note that, since $\marq_i \pleq \marq_j$, $\sigma$ is firable from $\marq_j$.
In addition, the monotonicity of \acp{PN} ensure that, with $\marqp_j$ given by $\marq_j \fire{\sigma} \marqp_j$, we have $\marq_j \pleq \marqp_j$.
Thus, we see that it is a sufficient condition for the \emph{non-termination} of the system (the system may be able to fire transitions infinitely often).
In fact, because $\pleq$ is a well quasi order (Lemma~\ref{lemm:wqo}), one can find in any infinite sequence $\marqi \fire{} \marq_1 \fire{} \dots$ two markings $\marq_i$ and $\marq_j$ such that $\marq_i \pleq \marq_j$.
And so, any infinite sequence is self-covering, and the existence of such a sequence is also necessary for the non-termination of the system.

\begin{defi}[Increasing self-covering sequence]
  Given an initialized \ac{PN} $\tupleN = \PTm$,
  an increasing self-covering sequence is a sequence of the form:
  \[
    \marqi \fire{\rho} \marq_i \fire{\sigma} \marq_j
  \]
  with $\rho$ and $\sigma$ two sequences of transitions of $T$
  and with $\marq_i \prec \marq_j$.
\end{defi}

Let $Q \subseteq P$ be the set of places $Q = \{q \in P \mid \marq_i(q) < \marq_j(q)\}$.
$Q \neq \emptyset$ since $\marq_i \prec \marq_j$.

With a similar reasoning to the above, we see that having such a sequence ensure that one can reach a marking $\marqp_j$ given by $\marq_j \fire{\sigma} \marqp_j$ such that $\marq_j \prec \marqp_j$.
Because of the constant effect of transitions, we know that $\forall q \in Q : \marq_j(q) < \marqp_j(q)$.
The unboundedness of the places in $Q$ follows.
\todo{A more formal proof that the existence of an increasing self-covering sequence is a necessary and sufficient condition for unboundedness on places is either to be done here or to reference.}



An \omark is a way to represent a set of markings which have the same number of tokens in some places, and may have any number of tokens, potentially an infinity, in the other places.
They are useful to effectively represent potentially infinite downward-closed set, like a coverability set or the sets of markings of an increasing self-covering sequence.

\begin{defi}[\omark]
  We define $\omega$ to be such that:
  $\omega \notin \mathbb{N}$
  and for all constant $c \in \mathbb{N}$:
  \begin{itemize}
    \item $c \leq \omega$
    \item $\omega + c = \omega$
    \item $\omega - c = \omega$
  \end{itemize}

  \emph{An \omark} \marq over a set of places $P$ is a function $\marq : P \mapsto \mathbb{N} \cup \{\omega\}$ that associates $\marq(p)$ tokens to each place $p \in P$.

  With $\mathbb{P}$ a set of parameters, $\omega \notin \mathbb{P}$,
  \emph{a parametric \omark} \marq over a set of places $P$ is a function $\marq : P \mapsto \mathbb{N} \cup \mathbb{P} \cup \{\omega\}$ that associates $\marq(p)$ tokens to each place $p \in P$.
\end{defi}

Note that an \omark \marq is a parametric \omark where $\marq(p) \in \mathbb{N} \cup \{\omega\}$ for all places $p \in P$.
Similarly, a parametric marking \marq is a parametric \omark where $\marq(p) \neq \omega$ for all places $p \in P$.
As for parametric markings, we often refer to a parametric \omark simply as \omark.

Having an \omark $\marq \in \Cover(\tupleN)$ denotes that for all marking $\marq_1$ such that $\marq_1(p) = \marq(p) \forall p \in \{p \mid \marq(p) \neq \omega\}$, there exists an marking $\marq_2$ in the reachability set of \tupleN such that $\marq_1 \pleq \marq_2$.
Notice also that an \omark stands for one and only one downward closed set.

\subsection{Karp and Miller procedure}

The Karp and Miller algorithm \cite{Karp69} is a classical algorithm to compute a coverability set of an initialized \ac{PN}.
More precisely, it constructs a coverability tree and uses an acceleration function to systematically detect self-covering sequences, and thus ensure the termination.

\begin{defi}[Coverability tree]
  Given a \ac{PN} $\tupleN = \PTm$, a coverability tree $\mathcal{T}$ of \tupleN is a labelled tree $\mathcal{T} = \langle N, B, n_0, \Lambda\rangle$ where:
  \begin{itemize}
    \item $N$ is the set of nodes of the tree.%, is a set of \omark of \tupleN such that $\downc(N) = \Cover(\tupleN)$.
    \item $n_0 \in N$ is the root of the tree, \lang{i.e.} $\nexists n \in N$ such that $(n, n_0) \in B$.
    \item $\Lambda : N \mapsto (\mathbb{N} \cup \{\omega\})^{|P|}$ is a labelling function that associate to each node a \textomega-marking of \tupleN.
    \item $B \subseteq N \times N$, the set of edges, is such that:
      \begin{itemize}
        \item with $(n_1, n_2) \in N^2$, if there exists an edge $(n_1, n_2) \in B$ then there exists a sequence $\sigma$ of transitions of $T$ such that $\Lambda(n_1) \fire{\sigma} \Lambda(n_2)$, and
        \item for all node $n \in N \setminus \{n_0\}$, there exists a path from the root to $n$, that is, there exists a sequence of edges of $B$ of the form $((n_0, n_1), (n_1, n_2), \dots, (n_{i}, n))$, $i > 1$, and
        \item there is no cycles, that is, there is no sequences of edges of $B$ of the form $((n_1, n_2), (n_2, n_3), \dots, (n_i, n_1))$.
      \end{itemize}
  \end{itemize}
  and such that $\downc(\{\Lambda(n) \mid n \in N\}) = \Cover(\tupleN)$.
\end{defi}

To keep $N$ finite, the Karp and Miller procedure exploits the monotonicity of \acp{PN} to introduce \omark{}s through an \emph{acceleration function} $\KMAcc$.
This function takes a marking \marq to accelerate and a set of markings $S$ as a base \todo{?} for the acceleration and returns a marking $\marq_\omega$ such that:
\[
  \marq_\omega(p) = 
  \begin{cases}
    \omega    &\text{if } \exists \marqp \in S : \marqp \prec \marq \text{ and } \marqp(p) < \marq(p) \\
    \marq(p)  &\text{otherwise}
  \end{cases}
\]

We denote by $\mathscr{T}_n$ the path in the tree from the root to $n$.

The algorithm constructs the tree $\mathcal{T}$ as follows:
The root $n_0$ of the tree is labelled with \marqi.
A frontier $F$ is defined to be the set of unprocessed nodes of the tree and is initialised to $\{n_0\}$.
Then, while $F$ is non empty, a node $n$ is chosen to be processed:
it is removed from $F$ and, if there is no node $n'$ in $\mathscr{T}_n$ such that $\Lambda(n) = \Lambda(n')$, for all \omark in $\{\KMAcc(\marq, \mathscr{T}_n) \mid \marq \in \Post(\Lambda(n))\}$, a node labelled with $\KMAcc(\marq, \mathscr{T}_n)$ is added to the frontier and to the tree as a child of $n$.

The correctness and the termination of the algorithm lies on the strict monotonicity of \acp{PN}, and was proved by Karp and Miller in their work \cite{Karp69}.

The Karp and Miller tree has a lot of convenient properties, and allows to answer coverability and \todo{} problems.
Furthermore, the Karp and Miller procedure can easily be adapted to some parametric problems \cite{David17}, as we will show in section~\todo{}.

However, this tree, although finite, is often much larger than the minimal coverability set, and cannot be constructed in reasonable time.
As a consequence, many improvement were proposed, as well as other algorithms with different approaches.

\subsection{An efficient computation method of the coverability set of Petri nets}
\label{sec:eff}

\citep{Geeraerts07thesis, Geeraerts07} propose another approach to the computation of the coverability set.
It is not based on the Karp and Miller algorithm and is not an alternative to the Karp and Miller procedure in the sense that it does not allow to answer the same set of questions that the Karp and Miller tree solves.
However, this techniques solve coverability problems more efficiently in practice.

As in the Karp and Miller algorithm, an acceleration function exploits the strict monotonicity of \acp{PN} to allow termination.
But here, the acceleration of a marking is performed with only one marking as the base (instead of a set of marking).

To choose the base to use, the algorithm work on pair of \omarks.
Thus we will need the following definitions:

Given a pair of \omarks $(\marq_1, \marq_2)$, we define:
\begin{itemize}
  \item $\Postb((\marq_1, \marq_2)) = \{(\marq_1, \marqp), (\marq_2, \marqp) \mid \marqp \in \Post(\marq_2)\}$,
  \item with $\marq_1 \prec \marq_2$, $\Accelb(\marq_1, \marq_2) = \{(\marq_2, \KMAcc(\{\marq_1\}, \marq_2))\}$.
    $\Accelb(\marq_1, \marq_2)$ is not defined whenever $\marq_1 \nprec \marq_2$,
\end{itemize}

With $R$ a set of pair of markings, we define:
\begin{itemize}
  \item $\Postb(R) = \bigcup_{(\marq_1, \marq_2) \in R} \Postb((\marq_1, \marq_2))$
  \item $\Accelb(R) = \bigcup_{(\marq_1, \marq_2) \in R}^{\marq_1 \prec \marq_2} \Accelb((\marq_1, \marq_2))$
  \item $\Flatten(R) = \{\marq \mid \exists \marqp : (\marqp, \marq) \in R\}$
\end{itemize}

The efficient computation of the coverability set of the marked \ac{PN} $\NPTm$ lies on the sequence $\CovSeq(\tupleN) = (V_i)_{i \geq 0}$ of pair of \omarks, where, for all marked \ac{PN} $\tupleN$ we have:
\begin{gather*}
  V_0 = \{(\marqi, \marqi)\} \text{ and } \\
  \forall i \geq 1 : V_i = V_{i-1} \cup \Postb(V_{i-1}) \cup \Accelb(V_{i-1})
\end{gather*}

One can shows that,
first, for all node $n$ of the Karp and Miller tree, there exists a value $k \geq 0$ of $i$ such that $\Lambda(n) \in \Flatten(V_k)$,
second, all the markings produced by $\Postb$ and $\Accelb$ are in the coverability set of \tupleN.
\todo{Indeed...}

This two results lead us to the following lemma:
\begin{lemm}[\cite{Geeraerts07}]
  Given a marked \ac{PN} \tupleN such that $\CovSeq(\tupleN) = (V_i)_{i \geq 0}$,
  there exists $k \geq 0$ such that for all $l \in \{0, ..., k-1\}$ we have that $\downc(\Flatten(V_l)) \subset \downc(\Flatten(V_{l+1}))$
  and for all $l \geq k : \downc(\Flatten(V_l)) = \Cover(\tupleN)$.
\end{lemm}

Thus, the algorithm idea is to compute $\CovSeq$ until it stabilizes, \lang{i.e.} to the lowest $l$ such that $\downc(\Flatten(V_l)) = \downc(\Flatten(V_{l-1}))$ and to return $\downc(\Flatten(V_l))$. \todo{Est-ce que $V_l = V_{l-1}$?}

To perform it efficiently, one can use an order $\sqsubseteq$ on the pair of markings to keep only the highest pair with respect to this order.
Let us denote by $\ominus$ the componentwise difference between two markings and to extend it to \omarks.
Formally, given two \omarks $\marq_1$ and $\marq_2$ on a set of places $P$, $(\marq_1 \ominus \marq_2)(p)$ is defined for all $p \in P$ as:
\[
  \begin{cases}
    \omega & \text{ whenever } \marq_1(p) = \omega \\
    -\omega & \text{ whenever } \marq_2(p) = \omega \text{ and } \marq_1(p) \neq \omega \\
    \marq_1(p) - \marq_2(p) & \text{ otherwise}
  \end{cases}
\]

For a set of \omarks $S$, $\maxs(S) = \{ s \in S \mid \nexists s' \in S, s \sqsubseteq s'\}$ is the set of highest \omark of $S$ with respect to $\sqsubseteq$.

Now we can define $\sqsubseteq$.
Given two pairs $(\marq_1, \marq_2)$ and $(\marqp_1, \marqp_2)$ of \omarks over a set of places $P$:
\[
  (\marq_1, \marq_2) \sqsubseteq (\marqp_1, \marqp_2) \Leftrightarrow
  \begin{cases}
    & \marq_1 \pleq \marqp_1 \\
    \wedge & \marq_2 \pleq \marqp_2 \\
    \wedge & \forall p \in P : (\marq_2 \ominus \marq_1)(p) \leq (\marqp_2 \ominus \marqp_1)(p)
  \end{cases}
\]

This order has properties \citep{Geeraerts07} that allows to keep the sets of markings of $\CovSeq$ small.
Thus, one can compute $\Cover(\tupleN)$ of a \ac{PN} \NPTm by computing the sequence $(V_i)_{i \geq 0}$ defined below until $\downc(\Flatten(V_i)) = \downc(\Flatten(V_{i-1}))$.
\begin{gather*}
  V_0 = \{(\marqi, \marqi)\} \text{ and } \\
  \forall i \geq 1 : V_i = \maxs(V_{i-1} \cup \Postb(V_{i-1}) \cup \Accelb(V_{i-1}))
\end{gather*}

At the end, we have that $\downc(\Flatten(V_i)) = \Cover(\tupleN)$.

The correction and termination of the algorithm as well as useful properties of $\sqsubseteq$ are presented in \citep{Geeraerts07, Ganty09}.

\subsection{\ac{EEC} algorithm}
\label{sec:eec}

\citep{Geeraerts07thesis, Geeraerts06}

\removed{A backward algorithm \citep{Finkel90, Abdulla96}}
%\subsection{A backward algorithm \citep{Finkel90, Abdulla96}}
%
%We will now present an algorithm to solve the coverability problem for a marking \marq of a \ac{PN} $\tupleN = \PTm$.
%
%This algorithm was introduced by Abdulla \lang{et al.} \cite{Abdulla96} for well structured transition systems, a more general class of models which includes \acp{PN}.
%It is close of the one introduced earlier in \cite{Finkel90}.
%
%Recall the definition for a marking of being coverable.
%\coverability*
%
%For convenience, we will use an other equivalent definition.
%
%\begin{defi}[Coverability]
%  Given an initialized \ac{PN} \NPTm and an upward-closed set $U$, $U$ is said coverable if there exists a marking \marqp such that $\marqp \in U$ and $\marqi \fire{*} \marqp$.
%\end{defi}
%
%By choosing $\upc(\marq)$ as $U$, these two definitions set out the same instance of the coverability problem.
%With a set of markings considered in the first definition, $U$ may be the union of their upward-closure in the second.
%
%We say it is a backward algorithm in the sense that it is based on the computation of the set $\Pre^*(\marq)$ and answer by checking whether $\marqi \in \Pre^*(\marq)$; unlike a forward approach which would have calculated the reachability set and conclude by checking whether \marq was in it. In other words, it compute all the configurations that can reach $U$ in any number of steps.
%
%The calculation is a fixed point algorithm that compute the increasing sequence, for the inclusion relation, of sets of markings: $(R_n)_{n \in \mathbb{N}}$, with $R_0 = U$ and $R_{n+1} = \Pre(R_n) \cup R_n$.
%Thus, $R_n$ is the set of markings from which there exists a sequence of at most $n$ transitions which may be fired and that cover $U$.
%Because, with $U$ an upward-closed set of markings, $\Pre(U)$ is upward-closed too%
%\footnote{This is due to the monotonicity of \acp{PN}, \todo{see for example cite\{someone\}}},
%and because the union of two upward-closed sets is an upward-closed set,
%$R_n$ is upward-closed for all $n$.
%
%\todo{summarize correctness and termination from \cite{Abdulla96}}

% vim: set spell spelllang=en :
